import tcpip_nuc
import workflow_gen
import misc
import socket
import struct
import threading
from PIL import Image, ImageOps
import queue
import socket
import os
import sys
import time
import numpy as np

image_queue = queue.Queue()

def listener_thread(IP_REMOTE, PORT_REMOTE, index, terminate_event):
    # Create a socket object
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # Connect to the remote server
    sock.connect((IP_REMOTE, PORT_REMOTE))
    print(sock)

    while True:
        try:
            # receive the header
            if terminate_event.is_set():
                break
            header_data = sock.recv(40)
            if len(header_data) != 40:
                raise ValueError(f'Header length should be 40 bytes, not {len(header_data)}')
            
            # parse the header
            print("header received")
            header = struct.unpack('I I I I I I I I I I', header_data)
            image_size, image_width, image_height, start_index, stop_index = header[0], header[1], header[2], header[8], header[9]
            stack_size = stop_index - start_index
            
            # receive the image data
            image_data = b''
            while len(image_data) < image_size:
                data = sock.recv(image_size - len(image_data))
                if not data:
                    raise socket.error('Incomplete image data')
                image_data += data
            
            # convert and save the image
            image = Image.frombytes('I;16', (image_width, image_height), image_data)
            rotated_image = image.rotate(90, expand=True)
            rotated_image.save(f'output{index}.png')
            grayscale_image = rotated_image.convert("L")
            #grayscale_image.show()
            # return the grayscale image
            image_queue.put(grayscale_image)
            
        except socket.error as e:
            print(f'Socket error: {e}')
            sock.close()
            break
            
        except Exception as e:
            print(f'Error: {e}')
            continue

    return None

def camera_thread(client, ymax, c_workflow, terminate_event, generate_event):
    while True:
        generate_event.wait()
        print('Checking Y position')
        dict = workflow_gen.workflow_to_dict('workflow.txt')
        #####################
        #check Y value against Ymax, if greater than, exit
        if float(dict['Start Position']['Y (mm)']) > ymax:
            print("YMax reached, terminating all threads")
            terminate_event.set()
            break
        print("Sending workflow to nuc")
        receieved = tcpip_nuc.wf_to_nuc(client, 'workflow.txt', c_workflow)
        generate_event.clear()

        ############
def processing_thread(terminate_event):
    while True:
        if terminate_event.is_set():
            break
        if image_queue.size():
            #process to find the most in focus of a stack
            image_queue.clear()